##Object Animation （简称OA动画）说明文档

### 解决了什么痛点，带来了什么好处？

1. 解放程序。以前有些动画只能程序来做，调整参数、预览都费时费力，策划或者动效人员还不一定满意效果，使用OA动画可以将关键参数暴露出来，由动效或者策划人员来调整参数，程序负责调用和按需修改动态参数即可，不用关心效果。
2. 解放动效。上一条中，动效或者策划如果想参与调整参数，会依赖程序先去实现好功能并暴露出参数，阻塞了流程。而使用OA动画，程序和动效完全可以并行工作。动效可以在没有程序参与，甚至功能都没做的情况下尽情发挥、尝试、随时调整。
3.  资源共享。由于OA动画核心简单，只要是unity项目都可以使用，所以每一个项目的每一个动画都可以方便的移植到别的项目，范围不限。

### 底层原理是什么？

核心原理就是，将某一个具体的动画，看作是几个不同类型属性的动画成分的组合，比如移动成分、旋转成分、缩放成分等等，每一个成分都对应一个继承自ScriptableObject的配置文件，然后把这些配置文件放到一个List中，这个List就最终决定了动画的大概样子。运行时，每一个成分都会产生一个对应的行为控制类，在Update中根据这个动画成分的配置参数修改物体的相应属性。

### 能否扩展？

可以。由底层原理可知，动画支持什么属性的修改，取决于List中有什么配置，根据动画的特点，向List中放入特定的配置即可。OA动画系统核心其实就相当于一个播放器，你想播放什么歌，就往“歌单”或者说“播放列表”放入什么歌就行。而有哪些“歌曲”可供选择，就取决于“曲库”的丰富度了。因此OA动画的扩展就相当于“创作新的歌曲”添加到“曲库”中。由于核心很简单、稳定，所以大部分工作其实是创作“歌曲”，目前所支持的功能，也就是一期开发的大部分功能，相当于“播放器”自带的曲库。


### 依赖问题

由于OA动画核心只是一个List加unity脚本生命周期驱动更新的组件，所以只依赖C#基础语法和Unity核心，不依赖如Dotween等的第三方插件，也不依赖任何游戏框架。当然，“歌曲”可以依赖任何第三方插件或者框架。

### 目前能实现什么功能？

#### 制作时的便捷工具：
1. 非运行时下的预览、整体播放、逐帧播放、倍速调整，详见demo_preview场景
2. 配置文件的导入、导出、克隆
3.  起点、终点调整之后的预览

#### 运行时功能
1.  支持动态的动画时长策略
2. 支持基准时长的同步
 
#### 移动
-  点成线模式。移动路径由多个点构成，目前只支持绝对的世界坐标（意味着UI如果要使用，就只能换算成世界坐标做动画）。支持可视化的路径编辑、中间点编辑。详见demo_move_point2Line
    1. 自动贝塞尔曲线模式。贝塞尔曲线由3个控制点生成，起点、终点由程序控制，动效设置中间点、快慢节奏，确定曲线特征
    
          + 中间点的计算算法策略可替换

    2. 贝塞尔曲线模式。贝塞尔曲线由大于3个的控制点生成，动效设置曲线、快慢节奏，程序根据需求控制起始点，中间所有的其他点根据起始点的偏移进行偏移（偏移算法可以根据需求自由更换扩展）
    3. 严格的路径模式，动效设定曲线、快慢节奏，程序根据需求控制起始点，中间所有的其他点根据起始点的偏移进行偏移（偏移算法可以根据需求自由更换扩展），到达每一个点时会触发一个事件，程序可以监听事件处理其他的事情
   
- 轴合成模式。移动路径由物体在x、y、z这3个轴上的运动合成，不同的节奏合成为不同的路径，支持世界坐标、局部坐标、UI上的锚点坐标详见demo_move_axis_combined
	- 超范围插值
	- 分轴/统一轴设置缓动曲线

#### 旋转
- 任意轴旋转模式，指定一条任意轴，围绕该轴做增量旋转。详见demo_rotate
- 三轴合成旋转模式,x、y、z轴各旋转各的，baseRotation全为0时是绝对旋转，否则为增量旋转。详见demo_rotate

#### 缩放
- 分轴缩放模式

### 最佳实践
- 各职能配合方面：策划出动画需求，定好该动画使用的clip文件的名字，特效和程序谁先开工谁创建clip文件，之后各干各的就行
- OA配置文件的制作方面：
    - 在合适的unity目录中右击鼠标->Create->OA动画->配置->Clip
    - 使用同样的方式创建需要的动画成分，比如点成线移动成分，任意轴旋转成分
    - 在clip文件的检视面板(Inspector)中,将各成分配置文件拖动到Animation Configs列表槽中
    - 在unity场景中创建合适的物体，挂上ObjectAnimationComponent组件，将clip文件拖拽到“设置clip”对应的属性槽中，之后即可进行参数调整、预览。
- 客户端程序使用方面：
	
	下面这段代码展示了常见的用法：
	
	```
    public void OAUseAddFiveCard(ObjectAnimationClip clip, Vector3 fromPos, Vector3 targetPos, float delay)
    {
        var oac = this.GetOrAddComponent<ObjectAnimationComponent>();//获取物体上的ObjectAnimationComponent组件
        oac.delayTime = delay;//根据实际需求设置播放延迟时间
        oac.onRealStart = xxx;//根据需要设置当延迟时间过后，动画真正开始播放时的回调
        oac.onfinished = xxx;//根据需要设置动画播放完成后的回调
        if (clip)
        {
            oac.SetOAClips(clip);//用clip文件初始化动画成分
            var bh = oac.GetBehaviour<WorldPostionMoveBehaviour>();//获取需要动态修改参数的动画成分
            if (bh != null)
            {
                bh.CorrectStart(fromPos);//修正起始值
                bh.CorrectEnd(targetPos);//修正最终值
            }            
        }
        oac.Play();//播放动画
    }
	```

###  未来还要支持什么功能？

1. loop次数支持，目前只能程序来控制循环播放的事情
2. 类粒子效果的更易于实现的方案实施
3. 倒放功能支持